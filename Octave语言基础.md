## 基本命令

符号|功能
:--:|:--:
%|注释
~=|不等于
&&|逻辑与
$||$ | 逻辑或
xor | 异或
PS('>> ')|把命令行提示符变成>>的样子
;|该行内容不会被下一行打印输出
disp|显示输出
format long|长格式输出
format short| 短格式输出

```octave
a = [1 2;3 4;5 6]
% 输出矩阵
a =

   1   2
   3   4
   5   6

v = [1 2 3]
%输出 行向量
v =

   1   2   3

v = [1 ; 2 ; 3]
%输出 列向量
 =

   1
   2
   3

v = 1 : 0.1 : 2    %表示从1到2以0.1为增量产生向量
%输出结果
v =

 Columns 1 through 5:

    1.000000000000000    1.100000000000000    1.200000000000000    1.300000000000000    1.400000000000000

 Columns 6 through 10:

    1.500000000000000    1.600000000000000    1.700000000000000    1.800000000000000    1.900000000000000

 Column 11:

    2.000000000000000

v = 1 : 6    %表示从1到6以默认1为增量产生向量
%输出结果
v =

   1   2   3   4   5   6

ones(2,3)    %表示生成一个2*3的矩阵，但是元素都为1
%输出结果
ans =

   1   1   1
   1   1   1

2*ones(2,3)    %表示生成一个2*3的矩阵，但元素都乘以2
%输出结果
ans =

   2   2   2
   2   2   2

rand(3,3)    %表示生成一个3*3的随机数字矩阵,且数值都在0和1之间
%输出结果
ans =

   0.648196535827540   0.366078526896446   0.245607599966753
   0.732983008747097   0.493296045921402   0.155764186571978
   0.832769124762435   0.394113950426234   0.536206366296943

w = -6 + sqrt(10)*(randn(1,1000));
%表示 w = -6 + 10^2 * "1*1000的随机矩阵"

hist(w)    %绘制关于w的直方图

hist(w,50)    %绘制关于w的直方图，并且条状分为50个

eye(4)    %生成一个4*4的单位矩阵
%输出结果
ans =

Diagonal Matrix

   1   0   0   0
   0   1   0   0
   0   0   1   0
   0   0   0   1




```

## 关于rand、randn、randi的区别
- **rand**生成均匀分布的<font color=ff0099>伪随机数</font>。分布在0～1之间。
  主要语法： rand(m,n)生成m*n的均匀分布的伪随机数。
            rand(m,n,'double')生成指定精度的均匀分布的伪随机数，参数还可以是single。
            rand(RandStream,m,n)利用指定的RandStream(随机种子？)生成伪随机数。
- **randn**生成<font color=ff0099>标准正态分布的伪随机数</font>。均值为0，方差为1。
- **randi**生成<font color=ff0099>均匀分布的伪随机数</font>。
  主要语法： randi(iMax)在开区间(0, iMax)生成均匀分布的伪随机数。
            randi(iMax,m,n)在开区间(0,iMax)生成$m\times n$的随机矩阵。
            randi([iMin,iMax],m,n)在开区间(iMin,iMax)生成$m\times n$的随机矩阵。

## 移动数据

```octave
size(a)    %表示输出矩阵a的尺寸

size(a,1)    %表示输出矩阵a的行数
size(a,2)    %表示输出矩阵a的列数

length(v)    %表示输出向量v的长度（最大的维度）

pwd    %显示当前Octave的安装路径

load 文件名.dat    %导入数据文件
load('文件名.dat')    %只是另一种写法

who    %列出当前octave储存的变量
whos    %更详细的列出当前储存的变量

clear 变量名    %删除指定的变量
clear    %删除所有已存储的变量数据

y = 变量名(1:10)    %将该变量下的前10个数据赋给y。

save 文件名.mat v;    %将变量v的数据存入指定文件名的文件
save 文件名.txt v -ascii    %将数据存入指定文件名的文档，编码为ascii。

%假定仍然是矩阵A
A = [1 2;3 4;5 6]
A =

   1   2
   3   4
   5   6

A(3,2)    %输出矩阵A里第3行第2个元素
A(2,:)    %输出矩阵A里第2行的所有元素
A(:,2)    %输出矩阵A里第2列的所有元素

A([1 3],:)    %输出矩阵A里第1和第3行的所有元素

A(:,2) = [10;11;12]    %将新的数据赋给矩阵A的第2列所有元素
A =

    1   10
    3   11
    5   12

A = [A,[100 ; 110 ; 120]]    %在矩阵A的右侧添加新的列矩阵
A =

     1    10   100
     3    11   110
     5    12   120

A(:)    %将矩阵A的所有元素按照列的先后顺序放入一个列向量里
ans =

     1
     3
     5
    10
    11
    12
   100
   110
   120

A = [1 2;3 4;5 6]    %定义矩阵A
A =

   1   2
   3   4
   5   6

B = [10 11;12 13;14 15]    %定义矩阵B
B =

   10   11
   12   13
   14   15

C = [A B]    %将矩阵B增加到矩阵A的右边，相当于两个矩阵“融合”，但不是相加
C =

    1    2   10   11
    3    4   12   13
    5    6   14   15

C = [A ; B]    %将矩阵B增加到矩阵A的下方
C =

    1    2
    3    4
    5    6
   10   11
   12   13
   14   15

```

## 数据计算

```octave

A = [1 2 ; 3 4 ; 5 6]
B = [11 12 ; 13 14 ; 15 16]
%矩阵A和B都是3*2矩阵，正常相乘会报错
A * B    %会报错
A .* B    %表示矩阵A和矩阵B对应位置的元素逐个相乘
>> A .* B
ans =

    11    24
    39    56
    75    96

A .^ 2    %计算矩阵A每个位置元素的平方
ans =

     1     4
     9    16
    25    36

v = [1;2;3]    %定义一个向量v
1 ./ v    %用1分别除以向量v的每一个元素，相当于求向量v每个元素的倒数。
ans =

    1.0000
    0.5000
    0.3333

log(v)    %求向量v每个元素的对数
ans =

         0
    0.6931
    1.0986

exp(v)    %以向量v的各个元素作为自然常数e的幂进行运算。这里分别是e的1次方、平方、立方。
ans =

    2.7183
    7.3891
   20.0855

abs(v)    %对向量v的各个元素求绝对值

abs([-1;-4;-7])
ans =

     1
     4
     7

-v    %对向量v的每个元素乘以-1

v + ones(length(v),1)    %向量v的每一个元素都与一个与向量v同样长度的向量的同位置元素相加。
ans =

     2
     3
     4

A'    %求矩阵A的转置矩阵。

a = [1 15 2 0.5]    %定义一个行向量a
val = max(a)    %输出向量a元素中最大的值并赋给val。

[val, ind] = max(a)    %输出最大值，并输出数据的索引。
ans =
val = 15
ind = 2

a < 3    %将向量a的元素分别与3对比，小于3的为True，大于3的为False，分别用1和0表示。

ans =
   1   0   1   1

find(a < 3)    %查找向量元素中大于3的，并输出索引值。

ans =
     1     3     4

magic(3)
%此函数将返回一个矩阵，被称为魔方阵或幻方(magic squares)。它的所有行、列、对角线元素加起来等于相同的值。
ans =
     8     1     6
     3     5     7
     4     9     2

A = magic(3)    %定义一个矩阵A。

A =

     8     1     6
     3     5     7
     4     9     2

>> [r,c] = find(A >= 7)    %查找矩阵A里大于等于7的元素，并将行号和列号分别存入r和c。

r =

     1
     3
     2


c =

     1
     2
     3

sum(a)    %将向量a的所有元素相加。

ans =
   18.5000

prod(a)    %求向量元素的乘积。

ans =

    15

floor(a)    %向负无穷大方向将向量元素舍入最近的整数值。

ans =

     1    15     2     0

ceil(a)    %向正无穷大方向将元素舍入最近的整数值。

ans =

     1    15     2     1

rand(3)

ans =

    0.8147    0.9134    0.2785
    0.9058    0.6324    0.5469
    0.1270    0.0975    0.9575

>> max(rand(3),rand(3))

ans =

    0.9649    0.9572    0.6787
    0.9595    0.8491    0.7577
    0.9706    0.9340    0.9157

max(A,[],1)    %在每一列找最大值。

ans =

     8     9     7

max(A,[],2)    %在每一行找最大值。
ans =

     8
     7
     9

max(max(A))    %找所有元素里的最大值。
max(A(:))    %功能相同的另一种写法。
ans =
     9

A(:)    %输出所有的元素。
ans =

     8
     3
     4
     1
     5
     9
     6
     7
     2

sum(A,1)    %计算每一列的和。
sum(A,2)    %计算每一行的和。

eye(9)    %生成一个9*9的单位矩阵。

ans =

     1     0     0     0     0     0     0     0     0
     0     1     0     0     0     0     0     0     0
     0     0     1     0     0     0     0     0     0
     0     0     0     1     0     0     0     0     0
     0     0     0     0     1     0     0     0     0
     0     0     0     0     0     1     0     0     0
     0     0     0     0     0     0     1     0     0
     0     0     0     0     0     0     0     1     0
     0     0     0     0     0     0     0     0     1

>> A = magic(9)    %生成一个9*9的魔幻方阵。

A =

    47    58    69    80     1    12    23    34    45
    57    68    79     9    11    22    33    44    46
    67    78     8    10    21    32    43    54    56
    77     7    18    20    31    42    53    55    66
     6    17    19    30    41    52    63    65    76
    16    27    29    40    51    62    64    75     5
    26    28    39    50    61    72    74     4    15
    36    38    49    60    71    73     3    14    25
    37    48    59    70    81     2    13    24    35

>> A .* eye(9)    %两者进行各个位置对应元素相乘。

ans =

    47     0     0     0     0     0     0     0     0
     0    68     0     0     0     0     0     0     0
     0     0     8     0     0     0     0     0     0
     0     0     0    20     0     0     0     0     0
     0     0     0     0    41     0     0     0     0
     0     0     0     0     0    62     0     0     0
     0     0     0     0     0     0    74     0     0
     0     0     0     0     0     0     0    14     0
     0     0     0     0     0     0     0     0    35

sum(sum(A .* eye(9)))    %求对角线的和。
ans =
   369

sum(sum(A.*flipud(eye(9))))    % filpud()表示上下方向反转矩阵。

ans =

   369

pinv(A)    %求矩阵A的逆矩阵。

A * pinv(A)    %一个方阵乘以它的逆矩阵，结果为一个单位矩阵。

ans =

    1.0000   -0.0000    0.0000
    0.0000    1.0000         0
   -0.0000    0.0000    1.0000

```